{"kind":"symbol","schemaVersion":{"major":0,"patch":0,"minor":3},"sections":[],"topicSections":[{"title":"Associated Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder"},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"abstract":[{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"variants":[{"paths":["\/documentation\/niocore\/bytetomessagedecoder"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"declarations":[{"languages":["swift"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"platforms":["Linux"]}],"kind":"declarations"},{"content":[{"anchor":"Purpose","level":3,"text":"Purpose","type":"heading"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" provides a simplified API for handling streams of incoming data that can be broken"},{"type":"text","text":" "},{"type":"text","text":"up into messages. This API boils down to two methods: "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":". These two methods, when"},{"type":"text","text":" "},{"type":"text","text":"implemented, will be used by a "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" paired with a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to decode the"},{"type":"text","text":" "},{"type":"text","text":"incoming byte stream into a sequence of messages."}],"type":"paragraph"},{"inlineContent":[{"text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that","type":"text"},{"text":" ","type":"text"},{"text":"is often necessary when implementing parsers in a SwiftNIO ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":". A ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"never needs to worry about how inbound bytes will be buffered, as ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":" deals with that","type":"text"},{"text":" ","type":"text"},{"text":"automatically. A ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" also never needs to worry about memory exclusivity violations","type":"text"},{"text":" ","type":"text"},{"text":"that can occur when re-entrant ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" operations occur, as ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" will deal with","type":"text"},{"text":" ","type":"text"},{"text":"those as well.","type":"text"}],"type":"paragraph"},{"anchor":"Implementing-ByteToMessageDecoder","level":3,"text":"Implementing ByteToMessageDecoder","type":"heading"},{"inlineContent":[{"text":"A type that implements ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" may implement two methods: decode and decodeLast. Implementations","type":"text"},{"text":" ","type":"text"},{"text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that","type":"text"},{"text":" ","type":"text"},{"text":"simply calls decode.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"decode","type":"codeVoice"},{"text":" is the main decoding method, and is the one that will be called most often. ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" is invoked","type":"text"},{"text":" ","type":"text"},{"text":"whenever data is received by the wrapping ","type":"text"},{"code":"ByteToMessageHandler","type":"codeVoice"},{"text":". It is invoked with a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" containing","type":"text"},{"text":" ","type":"text"},{"text":"all the received data (including any data previously buffered), as well as a ","type":"text"},{"code":"ChannelHandlerContext","type":"codeVoice"},{"text":" that can be","type":"text"},{"text":" ","type":"text"},{"text":"used in the ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decode"},{"text":" is called in a loop by the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":". This loop continues until one of two cases occurs:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The input ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" has no more readable bytes (i.e. ","type":"text"},{"code":".readableBytes == 0","type":"codeVoice"},{"text":"); OR","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" method returns ","type":"text"},{"code":".needMoreData","type":"codeVoice"},{"text":".","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are"},{"type":"text","text":" "},{"type":"text","text":"respected. It is entirely possible for "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" to receive either fewer bytes than a single message,"},{"type":"text","text":" "},{"type":"text","text":"or multiple messages in one go. Rather than have the "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" handle all of the complexity of this,"},{"type":"text","text":" "},{"type":"text","text":"the logic can be boiled down to a single choice: has the "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" been able to move the state forward"},{"type":"text","text":" "},{"type":"text","text":"or not? If it has, rather than containing an internal loop it may simply return "},{"code":".continue","type":"codeVoice"},{"type":"text","text":" in order to request that"},{"type":"text","text":" "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" be invoked again immediately. If it has not, it can return "},{"code":".needMoreData","type":"codeVoice"},{"type":"text","text":" to ask to be left alone until more"},{"type":"text","text":" "},{"type":"text","text":"data has been returned from the network."}],"type":"paragraph"},{"inlineContent":[{"text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return ","type":"text"},{"code":".needMoreData","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Otherwise, return ","type":"text"},{"code":".continue","type":"codeVoice"},{"text":". This will allow a ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" implementation to ignore the awkward way data","type":"text"},{"text":" ","type":"text"},{"text":"arrives from the network, and to just treat it as a series of ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" calls.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is a cousin of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":". It is also called in a loop, but unlike with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" this loop will only ever"},{"type":"text","text":" "},{"type":"text","text":"occur once: when the "},{"type":"codeVoice","code":"ChannelHandlerContext"},{"type":"text","text":" belonging to this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is about to become invalidated."},{"type":"text","text":" "},{"type":"text","text":"This invalidation happens in two situations: when EOF is received from the network, or when the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"is being removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". The distinction between these two states is captured by the value of"},{"type":"text","text":" "},{"type":"codeVoice","code":"seenEOF"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this condition, the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" must now produce any final messages it can with the bytes it has"},{"type":"text","text":" "},{"type":"text","text":"available. In protocols where EOF is used as a message delimiter, having "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" called with "},{"type":"codeVoice","code":"seenEOF == true"},{"type":"text","text":" "},{"type":"text","text":"may produce further messages. In other cases, "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" may choose to deliver any buffered bytes as “leftovers”,"},{"type":"text","text":" "},{"type":"text","text":"either in error messages or via "},{"type":"codeVoice","code":"channelRead"},{"type":"text","text":". This can occur if, for example, a protocol upgrade is occurring."}],"type":"paragraph"},{"inlineContent":[{"text":"As with ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":", ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" is invoked in a loop. This allows the same simplification as ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" allows: when","type":"text"},{"text":" ","type":"text"},{"text":"a message is completely parsed, the ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" function can return ","type":"text"},{"code":".continue","type":"codeVoice"},{"text":" and be re-invoked from the top,","type":"text"},{"text":" ","type":"text"},{"text":"rather than containing an internal loop.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the value of "},{"code":"seenEOF","type":"codeVoice"},{"type":"text","text":" may change between calls to "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" in some rare situations."}],"type":"paragraph"},{"anchor":"Implementers-Notes","level":3,"text":"Implementers Notes","type":"heading"},{"inlineContent":[{"type":"text","text":"\/\/\/ "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" will turn your "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":". "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":" "},{"type":"text","text":"also solves a couple of tricky issues for you. Most importantly, in a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" you do "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" need to"},{"type":"text","text":" "},{"type":"text","text":"worry about re-entrancy. Your code owns the passed-in "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" for the duration of the "},{"type":"codeVoice","code":"decode"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" call and"},{"type":"text","text":" "},{"type":"text","text":"can modify it at will."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If a custom frame decoder is required, then one needs to be careful when implementing"},{"type":"text","text":" "},{"type":"text","text":"one with "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":". Ensure there are enough bytes in the buffer for a"},{"type":"text","text":" "},{"type":"text","text":"complete frame by checking "},{"type":"codeVoice","code":"buffer.readableBytes"},{"type":"text","text":". If there are not enough bytes"},{"type":"text","text":" "},{"type":"text","text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive."}],"type":"paragraph"},{"inlineContent":[{"text":"To check for complete frames without modifying the reader index, use methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You  ","type":"text"},{"inlineContent":[{"text":"MUST","type":"text"}],"type":"emphasis"},{"text":" use the reader index when using methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"For example calling ","type":"text"},{"code":"buffer.getInteger(at: 0)","type":"codeVoice"},{"text":" is assuming the frame starts at the beginning of the buffer, which","type":"text"},{"text":" ","type":"text"},{"text":"is not always the case. Use ","type":"text"},{"code":"buffer.getInteger(at: buffer.readerIndex)","type":"codeVoice"},{"text":" instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you move the reader index forward, either manually or by using one of ","type":"text"},{"code":"buffer.read*","type":"codeVoice"},{"text":" methods, you must ensure","type":"text"},{"text":" ","type":"text"},{"text":"that you no longer need to see those bytes again as they will not be returned to you the next time ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" is","type":"text"},{"text":" ","type":"text"},{"text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to","type":"text"},{"text":" ","type":"text"},{"text":"perform your read operations on.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" passed in as ","type":"text"},{"code":"buffer","type":"codeVoice"},{"text":" is a slice of a larger buffer owned by the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"implementation. Some aspects of this buffer are preserved across calls to ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":", meaning that any changes to","type":"text"},{"text":" ","type":"text"},{"text":"those properties you make in your ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" method will be reflected in the next call to decode. In particular,","type":"text"},{"text":" ","type":"text"},{"text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,","type":"text"},{"text":" ","type":"text"},{"text":"those bytes are considered “consumed” and will not be available in future calls to ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Please note, however, that the numerical value of the ","type":"text"},{"code":"readerIndex","type":"codeVoice"},{"text":" itself is not preserved, and may not be the same","type":"text"},{"text":" ","type":"text"},{"text":"from one call to the next. Please do not rely on this numerical value: if you need","type":"text"},{"text":" ","type":"text"},{"text":"to recall where a byte is relative to the ","type":"text"},{"code":"readerIndex","type":"codeVoice"},{"text":", use an offset rather than an absolute value.","type":"text"}],"type":"paragraph"},{"anchor":"Using-ByteToMessageDecoder","level":3,"text":"Using ByteToMessageDecoder","type":"heading"},{"inlineContent":[{"type":"text","text":"To add a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" use"}],"type":"paragraph"},{"syntax":null,"code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"],"type":"codeListing"}],"kind":"content"}],"metadata":{"title":"ByteToMessageDecoder","role":"symbol","roleHeading":"Protocol","modules":[{"name":"NIOCore"}],"externalID":"s:7NIOCore20ByteToMessageDecoderP","symbolKind":"protocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"navigatorTitle":[{"kind":"identifier","text":"ByteToMessageDecoder"}]},"relationshipsSections":[{"type":"inheritedBy","title":"Inherited By","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"]},{"type":"conformingTypes","title":"Conforming Types","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"abstract":[{"text":"A decoder that splits the received ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" by a fixed number","type":"text"},{"text":" ","type":"text"},{"text":"of bytes. For example, if you received the following four fragmented packets:","type":"text"}],"type":"topic","url":"\/documentation\/nioextras\/fixedlengthframedecoder","kind":"symbol","title":"FixedLengthFrameDecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","navigatorTitle":[{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FixedLengthFrameDecoder"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"type":"topic","role":"symbol","title":"WriteObservingByteToMessageDecoder","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteObservingByteToMessageDecoder","kind":"identifier"}],"navigatorTitle":[{"text":"WriteObservingByteToMessageDecoder","kind":"identifier"}],"abstract":[{"type":"text","text":"Some "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s need to observe "},{"code":"write","type":"codeVoice"},{"text":"s (which are outbound events). ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s which","type":"text"},{"text":" ","type":"text"},{"text":"implement the ","type":"text"},{"code":"WriteObservingByteToMessageDecoder","type":"codeVoice"},{"text":" protocol will be notified about every outbound write.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","url":"\/documentation\/nioextras\/linebasedframedecoder","role":"symbol","title":"LineBasedFrameDecoder","navigatorTitle":[{"kind":"identifier","text":"LineBasedFrameDecoder"}],"type":"topic","abstract":[{"type":"text","text":"A decoder that splits incoming "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s around line end"},{"type":"text","text":" "},{"type":"text","text":"character(s) ("},{"code":"'\\n'","type":"codeVoice"},{"type":"text","text":" or "},{"code":"'\\r\\n'","type":"codeVoice"},{"text":").","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"LineBasedFrameDecoder"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/InboundOut":{"kind":"symbol","required":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut","url":"\/documentation\/niocore\/bytetomessagedecoder\/inboundout","type":"topic","abstract":[{"type":"text","text":"The type of the messages this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" decodes to."}],"role":"symbol","title":"InboundOut","fragments":[{"text":"associatedtype","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"InboundOut"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder":{"type":"topic","title":"NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder","url":"\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","abstract":[{"code":"ContentLengthHeaderFrameDecoder","type":"codeVoice"},{"type":"text","text":" is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’"},{"type":"text","text":" "},{"type":"text","text":"HTTP-like headers as used by for example by LSP (Language Server Protocol)."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ContentLengthHeaderFrameDecoder"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ContentLengthHeaderFrameDecoder"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","abstract":[{"type":"text","text":"A simplified version of "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" that can generate zero or one messages for each invocation of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" or "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Having "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"type":"topic","navigatorTitle":[{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"kind":"symbol","title":"NIOSingleStepByteToMessageDecoder","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPDecoder":{"navigatorTitle":[{"kind":"identifier","text":"HTTPDecoder"}],"kind":"symbol","title":"HTTPDecoder","url":"\/documentation\/niohttp1\/httpdecoder","type":"topic","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that parses HTTP\/1-style messages, converting them from"},{"type":"text","text":" "},{"type":"text","text":"unstructured bytes to a sequence of HTTP messages."}],"role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPDecoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decode(context:buffer:)":{"kind":"symbol","required":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","url":"\/documentation\/niocore\/bytetomessagedecoder\/decode(context:buffer:)","type":"topic","defaultImplementations":1,"abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"role":"symbol","title":"decode(context:buffer:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"decode"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier","text":"ByteBuffer"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"preciseIdentifier":"s:7NIOCore13DecodingStateO","kind":"typeIdentifier","text":"DecodingState"}]},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/SNIHandler":{"abstract":[{"type":"text","text":"A channel handler that can be used to arbitrarily edit a channel"},{"type":"text","text":" "},{"type":"text","text":"pipeline based on the hostname requested in the Server Name Indication"},{"type":"text","text":" "},{"type":"text","text":"portion of the TLS Client Hello."}],"role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SNIHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","navigatorTitle":[{"kind":"identifier","text":"SNIHandler"}],"type":"topic","url":"\/documentation\/niotls\/snihandler","title":"SNIHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"title":"NIOCore","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","abstract":[],"url":"\/documentation\/niocore","type":"topic","kind":"symbol","role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/wrapInboundOut(_:)":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)","title":"wrapInboundOut(_:)","role":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder\/wrapinboundout(_:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"wrapInboundOut"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"InboundOut"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore6NIOAnyV","text":"NIOAny"}],"abstract":[],"kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderRemoved(context:)-sa8l":{"role":"symbol","required":true,"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderRemoved","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","text":"ChannelHandlerContext","kind":"typeIdentifier"},{"text":")","kind":"text"}],"kind":"symbol","defaultImplementations":1,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","abstract":[{"type":"text","text":"Called once this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"type":"topic","url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderremoved(context:)-sa8l","title":"decoderRemoved(context:)"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"abstract":[{"text":"A decoder that splits the received ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" by the number of bytes specified in a fixed length header","type":"text"},{"text":" ","type":"text"},{"text":"contained within the buffer.","type":"text"},{"text":" ","type":"text"},{"text":"For example, if you received the following four fragmented packets:","type":"text"},{"type":"text","text":" "},{"type":"text","text":"+—+––+——+––+"},{"type":"text","text":" "},{"type":"text","text":"| A | BC | DEFG | HI |"},{"type":"text","text":" "},{"type":"text","text":"+—+––+——+––+"}],"url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","navigatorTitle":[{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","type":"topic","title":"LengthFieldBasedFrameDecoder","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf":{"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decodeLast","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"text":", ","kind":"text"},{"text":"buffer","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteBuffer","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore10ByteBufferV"},{"text":", ","kind":"text"},{"text":"seenEOF","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Bool","kind":"typeIdentifier","preciseIdentifier":"s:Sb"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"DecodingState","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore13DecodingStateO"}],"kind":"symbol","defaultImplementations":2,"required":true,"abstract":[{"text":"Decode from a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" when no more data is incoming and the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" is about to leave"},{"type":"text","text":" "},{"type":"text","text":"the pipeline."}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","url":"\/documentation\/niocore\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf","title":"decodeLast(context:buffer:seenEOF:)"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" to another message type."}],"role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","navigatorTitle":[{"kind":"identifier","text":"ByteToMessageDecoder"}],"type":"topic","url":"\/documentation\/niocore\/bytetomessagedecoder","title":"ByteToMessageDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u":{"type":"topic","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"shouldReclaimBytes","kind":"identifier"},{"text":"(","kind":"text"},{"text":"buffer","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier","text":"ByteBuffer"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:Sb","kind":"typeIdentifier","text":"Bool"}],"abstract":[{"text":"Determine if the read bytes in the given ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" should be reclaimed and their associated memory freed.","type":"text"},{"text":" ","type":"text"},{"text":"Be aware that reclaiming memory may involve memory copies and so is not free.","type":"text"}],"defaultImplementations":1,"url":"\/documentation\/niocore\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","title":"shouldReclaimBytes(buffer:)","required":true,"kind":"symbol","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderAdded(context:)-7trzq":{"kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderAdded","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"text":")","kind":"text"}],"title":"decoderAdded(context:)","abstract":[{"type":"text","text":"Called when this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is added to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"text":".","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","required":true,"url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderadded(context:)-7trzq","type":"topic","defaultImplementations":1,"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOWebSocket/WebSocketFrameDecoder":{"url":"\/documentation\/niowebsocket\/websocketframedecoder","navigatorTitle":[{"kind":"identifier","text":"WebSocketFrameDecoder"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"WebSocketFrameDecoder"}],"kind":"symbol","title":"WebSocketFrameDecoder","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder","abstract":[{"text":"An inbound ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that deserializes websocket frames into a structured","type":"text"},{"text":" ","type":"text"},{"text":"format for further processing.","type":"text"}]}}}