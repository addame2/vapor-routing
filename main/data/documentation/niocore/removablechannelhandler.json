{"sections":[],"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["Linux"],"languages":["swift"],"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RemovableChannelHandler","kind":"identifier"},{"text":" : ","kind":"text"},{"text":"ChannelHandler","kind":"typeIdentifier","preciseIdentifier":"s:7NIOCore14ChannelHandlerP","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"}]}]},{"kind":"content","content":[{"level":2,"type":"heading","anchor":"overview","text":"Overview"},{"style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":"When a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" gets torn down, every "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" in the "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":"’s "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" will be"},{"type":"text","text":" "},{"type":"text","text":"removed from the "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":". Those removals however happen synchronously and are not going through"},{"type":"text","text":" "},{"type":"text","text":"the methods of this protocol."}],"type":"paragraph"}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/niocore\/removablechannelhandler"]}],"metadata":{"symbolKind":"protocol","title":"RemovableChannelHandler","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"roleHeading":"Protocol","navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"modules":[{"name":"NIOCore"}],"externalID":"s:7NIOCore23RemovableChannelHandlerP"},"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is a "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that can be dynamically removed from a "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" whilst"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" is operating normally."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"type":"text","text":" is required to remove itself from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" (using"},{"type":"text","text":" "},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"type":"text","text":") as soon as possible."}],"topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc"]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"relationshipsSections":[{"type":"inheritsFrom","kind":"relationships","title":"Inherits From","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"]},{"type":"conformingTypes","kind":"relationships","title":"Conforming Types","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler"]}],"kind":"symbol","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler"},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSServerHandshakeHandler":{"navigatorTitle":[{"text":"SOCKSServerHandshakeHandler","kind":"identifier"}],"abstract":[{"type":"text","text":"Add this handshake handler to the front of your channel, closest to the network."},{"type":"text","text":" "},{"type":"text","text":"The handler will receive bytes from the network and run them through a state machine"},{"type":"text","text":" "},{"type":"text","text":"and parser to enforce SOCKSv5 protocol correctness. Inbound bytes will by parsed into"},{"type":"text","text":" "},{"type":"codeVoice","code":"ClientMessage"},{"type":"text","text":" for downstream consumption. Send "},{"type":"codeVoice","code":"ServerMessage"},{"type":"text","text":" to this"},{"type":"text","text":" "},{"type":"text","text":"handler."}],"title":"SOCKSServerHandshakeHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SOCKSServerHandshakeHandler","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler","url":"\/documentation\/niosocks\/socksserverhandshakehandler"},"https://en.wikipedia.org/wiki/Pcap":{"titleInlineContent":[{"code":".pcap","type":"codeVoice"},{"type":"text","text":" file"}],"title":".pcap file","type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","url":"https:\/\/en.wikipedia.org\/wiki\/Pcap"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/HTTPResponseCompressor":{"navigatorTitle":[{"kind":"identifier","text":"HTTPResponseCompressor"}],"abstract":[{"type":"text","text":"A HTTPResponseCompressor is a duplex channel handler that handles automatic streaming compression of"},{"type":"text","text":" "},{"type":"text","text":"HTTP responses. It respects the client’s Accept-Encoding preferences, including q-values if present,"},{"type":"text","text":" "},{"type":"text","text":"and ensures that clients are served the compression algorithm that works best for them."}],"title":"HTTPResponseCompressor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPResponseCompressor"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","url":"\/documentation\/niohttpcompression\/httpresponsecompressor"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPRequestEncoder":{"navigatorTitle":[{"kind":"identifier","text":"HTTPRequestEncoder"}],"abstract":[{"type":"text","text":"A "},{"code":"ChannelOutboundHandler","type":"codeVoice"},{"type":"text","text":" that can serialize HTTP requests."}],"title":"HTTPRequestEncoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPRequestEncoder"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","url":"\/documentation\/niohttp1\/httprequestencoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AcceptBackoffHandler":{"navigatorTitle":[{"text":"AcceptBackoffHandler","kind":"identifier"}],"abstract":[{"text":"A ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that implements a backoff for a ","type":"text"},{"code":"ServerChannel","type":"codeVoice"},{"text":" when accept produces an ","type":"text"},{"code":"IOError","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"These errors are often recoverable by reducing the rate at which we call accept.","type":"text"}],"title":"AcceptBackoffHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AcceptBackoffHandler","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","url":"\/documentation\/niocore\/acceptbackoffhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"title":"NIOCore","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","abstract":[],"url":"\/documentation\/niocore","type":"topic","kind":"symbol","role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLServerHandler":{"navigatorTitle":[{"text":"NIOSSLServerHandler","kind":"identifier"}],"abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL. This","type":"text"},{"text":" ","type":"text"},{"text":"handler can be used in channels that are acting as the server in","type":"text"},{"text":" ","type":"text"},{"text":"the TLS dialog. For client connections, use the ","type":"text"},{"code":"NIOSSLClientHandler","type":"codeVoice"},{"text":".","type":"text"}],"title":"NIOSSLServerHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"NIOSSLServerHandler","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","url":"\/documentation\/niossl\/niosslserverhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSClientHandler":{"navigatorTitle":[{"text":"SOCKSClientHandler","kind":"identifier"}],"abstract":[{"text":"Connects to a SOCKS server to establish a proxied connection","type":"text"},{"text":" ","type":"text"},{"text":"to a host. This handler should be inserted at the beginning of a","type":"text"},{"text":" ","type":"text"},{"text":"channel’s pipeline. Note that SOCKS only supports fully-qualified","type":"text"},{"text":" ","type":"text"},{"text":"domain names and IPv4 or IPv6 sockets, and not UNIX sockets.","type":"text"}],"title":"SOCKSClientHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"SOCKSClientHandler","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","url":"\/documentation\/niosocks\/socksclienthandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPResponseEncoder":{"abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"ChannelOutboundHandler"},{"text":" that can serialize HTTP responses.","type":"text"}],"title":"HTTPResponseEncoder","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPResponseEncoder","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"text":"HTTPResponseEncoder","kind":"identifier"}],"type":"topic","url":"\/documentation\/niohttp1\/httpresponseencoder"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestCompressor":{"navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestCompressor"}],"abstract":[{"text":"NIOHTTPResponseCompressor is an outbound channel handler that handles automatic streaming compression of","type":"text"},{"text":" ","type":"text"},{"text":"HTTP requests.","type":"text"}],"title":"NIOHTTPRequestCompressor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestCompressor"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","url":"\/documentation\/niohttpcompression\/niohttprequestcompressor"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientUpgradeHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOHTTPClientUpgradeHandler"}],"abstract":[{"type":"text","text":"A client-side channel handler that sends a HTTP upgrade handshake request to perform a HTTP-upgrade."},{"type":"text","text":" "},{"type":"text","text":"When the first HTTP request is sent, this handler will add all appropriate headers to perform an upgrade to"},{"type":"text","text":" "},{"type":"text","text":"the a protocol. It may add headers for a set of protocols in preference order."},{"type":"text","text":" "},{"type":"text","text":"If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler simply"},{"type":"text","text":" "},{"type":"text","text":"removes itself from the pipeline. If the upgrade is successful, it upgrades the pipeline to the new protocol."}],"title":"NIOHTTPClientUpgradeHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPClientUpgradeHandler"}],"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","url":"\/documentation\/niohttp1\/niohttpclientupgradehandler"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOWritePCAPHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","url":"\/documentation\/nioextras\/niowritepcaphandler","role":"symbol","title":"NIOWritePCAPHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOWritePCAPHandler"}],"navigatorTitle":[{"kind":"identifier","text":"NIOWritePCAPHandler"}],"type":"topic","abstract":[{"text":"A ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that can write a ","type":"text"},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","isActive":true,"type":"reference"},{"text":" containing the send\/received","type":"text"},{"text":" ","type":"text"},{"text":"data as synthesized TCP packet captures.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLClientHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","url":"\/documentation\/niossl\/niosslclienthandler","role":"symbol","title":"NIOSSLClientHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLClientHandler"}],"navigatorTitle":[{"kind":"identifier","text":"NIOSSLClientHandler"}],"type":"topic","abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL.","type":"text"},{"text":" ","type":"text"},{"text":"This handler can be used in channels that are acting as the client","type":"text"},{"text":" ","type":"text"},{"text":"in the TLS dialog. For server connections, use the ","type":"text"},{"code":"NIOSSLServerHandler","type":"codeVoice"},{"text":".","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerUpgradeHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","url":"\/documentation\/niohttp1\/httpserverupgradehandler","role":"symbol","title":"HTTPServerUpgradeHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"navigatorTitle":[{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"type":"topic","abstract":[{"text":"A server-side channel handler that receives HTTP requests and optionally performs a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"text":"Removes itself from the channel pipeline after the first inbound request on the connection, regardless of","type":"text"},{"text":" ","type":"text"},{"text":"whether the upgrade succeeded or not.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/ApplicationProtocolNegotiationHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","url":"\/documentation\/niotls\/applicationprotocolnegotiationhandler","role":"symbol","title":"ApplicationProtocolNegotiationHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"navigatorTitle":[{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"type":"topic","abstract":[{"text":"A helper ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that makes it easy to swap channel pipelines","type":"text"},{"text":" ","type":"text"},{"text":"based on the result of an ALPN negotiation.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler/removeHandler(context:removalToken:)-2jaoc":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc","url":"\/documentation\/niocore\/removablechannelhandler\/removehandler(context:removaltoken:)-2jaoc","required":true,"role":"symbol","title":"removeHandler(context:removalToken:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"removeHandler"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"removalToken"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"RemovalToken","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC12RemovalTokenV"},{"kind":"text","text":")"}],"type":"topic","abstract":[{"text":"Ask the receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" as soon as possible.","type":"text"},{"text":" ","type":"text"},{"text":"The receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" may elect to remove itself sometime after this method call, rather than","type":"text"},{"type":"text","text":" "},{"type":"text","text":"immediately, but if it does so it must take the necessary precautions to handle events arriving between the"},{"type":"text","text":" "},{"type":"text","text":"invocation of this method and the call to "},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"type":"text","text":" that triggers the actual"},{"type":"text","text":" "},{"type":"text","text":"removal."}],"kind":"symbol","defaultImplementations":1},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","url":"\/documentation\/niocore\/removablechannelhandler","role":"symbol","title":"RemovableChannelHandler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"type":"topic","abstract":[{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is a ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that can be dynamically removed from a ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" whilst","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" is operating normally.","type":"text"},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is required to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" (using","type":"text"},{"text":" ","type":"text"},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"text":") as soon as possible.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandler":{"kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ChannelHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","url":"\/documentation\/niocore\/channelhandler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelHandler"}],"role":"symbol","title":"ChannelHandler","abstract":[{"text":"You should ","type":"text"},{"inlineContent":[{"type":"text","text":"never"}],"type":"emphasis"},{"text":" implement this protocol directly. Please implement one of its sub-protocols.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BackPressureHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","navigatorTitle":[{"text":"BackPressureHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/backpressurehandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BackPressureHandler","kind":"identifier"}],"role":"symbol","type":"topic","title":"BackPressureHandler","abstract":[{"type":"text","text":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough."},{"type":"text","text":" "},{"type":"text","text":"It will start reading again once pending data was written."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","navigatorTitle":[{"text":"NIOSSLHandler","kind":"identifier"}],"url":"\/documentation\/niossl\/niosslhandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLHandler","kind":"identifier"}],"role":"symbol","type":"topic","title":"NIOSSLHandler","abstract":[{"type":"text","text":"The base class for all NIOSSL handlers. This class cannot actually be instantiated by"},{"type":"text","text":" "},{"type":"text","text":"users directly: instead, users must select which mode they would like their handler to"},{"type":"text","text":" "},{"type":"text","text":"operate in, client or server."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IdleStateHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","navigatorTitle":[{"text":"IdleStateHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/idlestatehandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"IdleStateHandler","kind":"identifier"}],"role":"symbol","type":"topic","title":"IdleStateHandler","abstract":[{"type":"text","text":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPServerRequestAggregator":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","navigatorTitle":[{"text":"NIOHTTPServerRequestAggregator","kind":"identifier"}],"url":"\/documentation\/niohttp1\/niohttpserverrequestaggregator","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPServerRequestAggregator","kind":"identifier"}],"role":"symbol","type":"topic","title":"NIOHTTPServerRequestAggregator","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that handles HTTP chunked "},{"type":"codeVoice","code":"HTTPServerRequestPart"},{"type":"text","text":" "},{"type":"text","text":"messages by aggregating individual message chunks into a single"},{"type":"text","text":" "},{"type":"codeVoice","code":"NIOHTTPServerRequestFull"},{"type":"text","text":"."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestDecompressor":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","navigatorTitle":[{"text":"NIOHTTPRequestDecompressor","kind":"identifier"}],"url":"\/documentation\/niohttpcompression\/niohttprequestdecompressor","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPRequestDecompressor","kind":"identifier"}],"role":"symbol","type":"topic","title":"NIOHTTPRequestDecompressor","abstract":[],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","navigatorTitle":[{"text":"ByteToMessageHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/bytetomessagehandler","conformance":{"constraints":[{"code":"Decoder","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}]},"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageHandler","kind":"identifier"}],"role":"symbol","type":"topic","title":"ByteToMessageHandler","abstract":[{"type":"text","text":"A handler which turns a given "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" into a "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that can then be added to a"},{"type":"text","text":" "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerProtocolErrorHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","navigatorTitle":[{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"url":"\/documentation\/niohttp1\/httpserverprotocolerrorhandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"role":"symbol","type":"topic","title":"HTTPServerProtocolErrorHandler","abstract":[{"text":"A simple channel handler that catches errors emitted by parsing HTTP requests","type":"text"},{"text":" ","type":"text"},{"text":"and sends 400 Bad Request responses.","type":"text"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientResponseAggregator":{"type":"topic","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that handles HTTP chunked "},{"type":"codeVoice","code":"HTTPClientResponsePart"},{"type":"text","text":" "},{"type":"text","text":"messages by aggregating individual message chunks into a single"},{"type":"text","text":" "},{"type":"codeVoice","code":"NIOHTTPClientResponseFull"},{"type":"text","text":"."}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"navigatorTitle":[{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"url":"\/documentation\/niohttp1\/niohttpclientresponseaggregator","kind":"symbol","title":"NIOHTTPClientResponseAggregator","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPResponseDecompressor":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","navigatorTitle":[{"text":"NIOHTTPResponseDecompressor","kind":"identifier"}],"url":"\/documentation\/niohttpcompression\/niohttpresponsedecompressor","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPResponseDecompressor","kind":"identifier"}],"role":"symbol","type":"topic","title":"NIOHTTPResponseDecompressor","abstract":[],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerPipelineHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that handles HTTP pipelining by buffering inbound data until a","type":"text"},{"text":" ","type":"text"},{"text":"response has been sent.","type":"text"}],"kind":"symbol","type":"topic","url":"\/documentation\/niohttp1\/httpserverpipelinehandler","title":"HTTPServerPipelineHandler"}}}